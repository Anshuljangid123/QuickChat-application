import cloudinary from "../lib/cloudinary.js";
import { generateToken } from "../lib/utils.js";
import User from "../models/User.js";
import bcrypt from "bcryptjs";


// signup new user 
export const signup = async(req , res) => {
    const {fullName , email , password , bio} = req.body;

    try{
        // whether these data are available or not 
        if(!fullName || !email || !password || !bio ) {
            return res.json({success: false , message : "missing details "})
        }

        const user = await User.findOne({email}) ; 

        if(user){
            // user already exist 
            return res.json({success : false  , message : "account already exists"})
        }

        // if the new user come  , generate encripted password 

        // for the new user we are encrypting the password , using the salt and given password string using the bcrupt library 

        const salt = await bcrypt.genSalt(10) ;
        // hashing the password . 
        const hashedPassword = await bcrypt.hash(password , salt);

        const newUser = await User.create({
            fullName , email , password : hashedPassword  , bio 
        });

        // creat token 
        // _id is auto generated by the mongo db which here we used in token generation . 
        const token = generateToken(newUser._id); // to generate a token we required a user id .

        res.json({success : true , userData : newUser , token , message : "account created successfully "});

    }catch(error){
        res.json({success : false , message : error.message});
        console.log(error.message);
        
    }
}

// controller to login the user 

export const login = async(req , res) => {

    try{
        const {email , password} = req.body ; 
        // find the user for this email id 
        const userData = await User.findOne({email});
        if(userData == null){
            return res.json({success : false  , message : "user not found in the db "});
        }
        const isPasswordCorrect = await bcrypt.compare(password , userData.password);
        // if the password from the body do not match the password from the db then they are not the same user and cannot be login 

        if(!isPasswordCorrect){
            return res.json({success : false , message : "invalid credentials"});
        }

        // now the password from the body and the db are both same 
        // so generate the token for the authnetication 

        const token = generateToken(userData._id);
        // here we are sending the token to the frontend or headers 

        res.json({success : true  , userData, token , message : "Account created successfully "});

    }catch(error){  
        res.json({success : false , message : error.message});
        console.log(error.message);
    }
}


// whether the user is authenticated or not 

export const checkAuth = (req , res) => {
    res.json({success : true , user : req.user});

}

// controller to update the user profile details 
export const updateProfile = async(req , res) => {
    try{
        const {profilePic , bio , fullName} = req.body;

        const userId = req.user._id ; 
        let updatedUser  ; 
        // check the user want to update the profile pic also or just bio and fullname . 
        if(!profilePic){
            // update name and bio , we do not have profilePic 
            updatedUser =  await User.findByIdAndUpdate(userId , {bio , fullName}, {new : true})
        }
        else{
            //profile pic is also provided 
            // upload the pic on the cloudinary and from there we will get the url of the pic .

            const upload  = await cloudinary.uploader.upload(profilePic);
            console.log("Cloudinary upload result: ---------", upload);
            // it will return a url 
            // it will upload the profile pic

            updatedUser = await User.findByIdAndUpdate(userId , {profilePic : upload.secure_url , bio , fullName} , {new : true});
        }
        res.json({success: true , user : updatedUser});
    }
    catch(error){
        res.json({success : false , message : error.message})
        console.log(error.message);
    }
}